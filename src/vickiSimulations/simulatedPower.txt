rm(list=ls())

# this simulation assumes normality of data
numSimulations <- 100

# there are typically around 70-75 non-rare families or genra that are called by the RDP
# classification scheme in diverse sample types (such as gut or oral 
# microbiota) in large datasets (Fodor lab, unpublished data)
numTaxa <- 75

numSubtype1<- 50
numSubtype2 <- 50

# to simplify the simulation, we assume that 
# every taxa is significantly associated for both main effects
# and interaction terms - 
# Our calculation therefore yields the power for detecting true positives
# and this simulation does not address what fraction of true negatives
# are called in error

# we allow one effect size for main effects and one for interaction terms
mainEffectSize = .6
interactionEffectSize = 0.9

# We assume 50% enrollment of African American in our study
# consistent with our recruitment goals
fractionAA <- 0.50

subtype1IsAA <- runif(numSubtype1) <= fractionAA 
subtype2isAA <- runif(numSubtype2) <= fractionAA 
allAreAA <- c(subtype1IsAA ,subtype2isAA)
allIsSubtype1 <- c( rep(TRUE, numSubtype1), rep(FALSE, numSubtype2) )

powerSubtype <- vector()
powerRace <- vector()
powerInteraction <- vector()

for( i in 1:numSimulations)
{
	pValuesSubType <- vector()
	pValuesRace <- vector()
	pValuesInteraction <- vector()
		
	for( j in 1:numTaxa)
	{
		subtype1Vals <- vector()
		
		for ( k in 1:numSubtype1 ) 
		{
			thisEffectSize = 0;
			
			# add in the main effect for race
			if( subtype1IsAA[k] ) 
			{
				thisEffectSize = thisEffectSize +  mainEffectSize;
			}
			
			subtype1Vals[k] = rnorm(1, mean= thisEffectSize )
		}
		
		subtype2Vals <- vector()
		
		for ( k in 1:numSubtype2) 
		{
			thisEffectSize = mainEffectSize;
			
			# add in the main effect for race (here with the interaction term because the 
			# effect size is larger for AA with subtype2 than for AA and subtype 1
			if( subtype2isAA[k]) 
			{
				thisEffectSize = thisEffectSize +  mainEffectSize + interactionEffectSize;
			}
			
			subtype2Vals[k] = rnorm(1, mean= thisEffectSize )
		}
	
		# horribly inefficient here, but seems to still be fast enough
		data <- c( subtype2Vals, subtype1Vals ) 
		
		# build model with the interaction term
		myLm <- lm( data ~ allIsSubtype1 * allAreAA ) 
		
		#record p-values with anova
		myAnova <- anova(myLm)
		
		# use ANOVA to capture the p-values
		pValuesSubType[j] <- anova(myLm)$"Pr(>F)"[1]
		pValuesRace[j] <- anova(myLm)$"Pr(>F)"[2]
		pValuesInteraction[j] <- anova(myLm)$"Pr(>F)"[3]
	}
	
	# adjust the p-values
	caseControlAdjust <- p.adjust( pValuesSubType, method="BH")
	
	numTrueFound <-0 
	
	for ( j in 1:numTaxa ) 
	{	
		if( caseControlAdjust[j] < 0.10  )
			numTrueFound = numTrueFound + 1
	}
	
	powerSubtype[i] =  numTrueFound  
	
	raceAdjust <- p.adjust( pValuesRace, method="BH")
	
	numTrueFound <-0 
	
	for ( j in 1:numTaxa ) 
	{
		if( raceAdjust[j] < 0.10  )
			numTrueFound = numTrueFound + 1
	}
	
	powerRace[i] =  numTrueFound 
	
	interactionAdjust <- p.adjust( pValuesInteraction, method="BH")
	
	numTrueFound <-0 
	
	for ( j in 1:numTaxa ) 
	{
		if( interactionAdjust[j] < 0.10  )
			numTrueFound = numTrueFound + 1
	}
	
	powerInteraction[i] =  numTrueFound 
}

# print out mean power across all simulations
mean(powerSubtype)
mean(powerRace)
mean(powerInteraction)